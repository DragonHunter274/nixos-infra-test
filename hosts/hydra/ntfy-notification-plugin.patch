diff --git a/src/lib/Hydra/Plugin/NtfyNotification.pm b/src/lib/Hydra/Plugin/NtfyNotification.pm
new file mode 100644
index 00000000..8f77a94b
--- /dev/null
+++ b/src/lib/Hydra/Plugin/NtfyNotification.pm
@@ -0,0 +1,263 @@
+package Hydra::Plugin::NtfyNotification;
+
+use strict;
+use warnings;
+use parent 'Hydra::Plugin';
+use HTTP::Request;
+use LWP::UserAgent;
+use Hydra::Helper::CatalystUtils;
+use JSON::MaybeXS;
+
+=head1 NAME
+
+NtfyNotification - hydra-notify plugin for sending ntfy.sh notifications about
+build results
+
+=head1 DESCRIPTION
+
+This plugin reports build statuses to ntfy.sh topics. One can configure
+which builds are reported to which topics, and whether reports should be on
+state change (regressions and improvements), or for each build.
+
+=head1 CONFIGURATION
+
+The module is configured using the C<ntfy> block in Hydra's config file. There
+can be multiple such blocks in the config file, each configuring different (or
+even the same) set of builds and how they report to ntfy topics.
+
+The following entries are recognized in the C<ntfy> block:
+
+=over 4
+
+=item jobs
+
+A pattern for job names. All builds whose job name matches this pattern will
+emit a message to the designated ntfy topic (see C<topic>). The pattern will
+match the whole name, thus leaving this field empty will result in no
+notifications being sent. To match on all builds, use C<.*>.
+
+=item topic
+
+The ntfy.sh topic name to send notifications to. This will be posted to
+C<https://ntfy.sh/{topic}> unless a custom C<server> is specified.
+
+=item server
+
+(Optional) The base URL of the ntfy server. If not provided, defaults to
+C<https://ntfy.sh>.
+
+=item token
+
+(Optional) Authentication token for the ntfy server. If provided, will be
+sent as a Bearer token in the Authorization header.
+
+=item priority
+
+(Optional) Message priority (1=min, 2=low, 3=default, 4=high, 5=urgent).
+Defaults to 3. Failed builds use priority 4 (high), successful builds use
+the configured priority.
+
+=item force
+
+(Optional) An I<integer> indicating whether to report on every build or only on
+changes in the status. If not provided, defaults to 0, that is, sending reports
+only when build status changes from success to failure, and vice-versa. Any
+other value results in reporting on every build.
+
+=item per_job
+
+(Optional) If set to 1, each build is sent to a separate topic derived from
+the job name. The configured C<topic> is used as a prefix, and the job name
+is appended with dots and colons replaced by hyphens. For example, with
+C<topic = hydra> and a job named C<myproject:jobset:handbrake.x86_64-linux>,
+the notification is sent to topic C<hydra-myproject-jobset-handbrake-x86_64-linux>.
+This allows ntfy subscribers to use wildcard patterns (e.g. C<hydra-*>) to
+filter notifications. Topic names are truncated to 64 characters (ntfy limit)
+and only contain C<A-Za-z0-9>, C<->, and C<_>. Defaults to 0.
+
+=back
+
+=head1 EXAMPLE CONFIGURATION
+
+  # Single topic for all matching builds
+  <ntfy>
+    jobs = myproject:.*
+    topic = hydra-builds
+    server = https://ntfy.sh
+    priority = 3
+    force = 0
+  </ntfy>
+
+  # Per-job topics (e.g. hydra-myproject-jobset-handbrake-x86_64-linux)
+  <ntfy>
+    jobs = myproject:.*
+    topic = hydra
+    server = https://ntfy.sh
+    per_job = 1
+  </ntfy>
+
+=cut
+
+sub isEnabled {
+    my ($self) = @_;
+    return defined $self->{config}->{ntfy};
+}
+
+sub renderDuration {
+    my ($build) = @_;
+    my $duration = $build->stoptime - $build->starttime;
+    my $res = "";
+    if ($duration >= 24*60*60) {
+       $res .= int($duration / (24*60*60)) . "d";
+    }
+    if ($duration >= 60*60) {
+        $res .= int(($duration / (60*60)) % 24) . "h";
+    }
+    if ($duration >= 60) {
+        $res .= int(($duration / 60) % 60) . "m";
+    }
+    $res .= ($duration % 60) . "s";
+    return $res;
+}
+
+sub buildFinished {
+    my ($self, $topbuild, $dependents) = @_;
+    my $cfg = $self->{config}->{ntfy};
+    my @config = defined $cfg ? ref $cfg eq "ARRAY" ? @$cfg : ($cfg) : ();
+
+    my $baseurl = $self->{config}->{'base_uri'} || "http://localhost:3000";
+
+    # Sanitize a string for use in ntfy topic names (A-Za-z0-9, -, _ only).
+    my $sanitize_topic = sub {
+        my ($s) = @_;
+        $s =~ s/[.:]+/-/g;     # Replace dots and colons with hyphens
+        $s =~ s/[^A-Za-z0-9_-]//g;  # Strip anything else
+        $s =~ s/-+/-/g;        # Collapse consecutive hyphens
+        $s =~ s/^-|-$//g;      # Trim leading/trailing hyphens
+        return substr($s, 0, 64);
+    };
+
+    # Figure out to which topics to send notification. For each topic
+    # we send one aggregate message.
+    my %topics;
+    foreach my $build ($topbuild, @{$dependents}) {
+        my $jobName = showJobName $build;
+        my $buildStatus = $build->buildstatus;
+        my $cancelledOrAborted = $buildStatus == 4 || $buildStatus == 3;
+
+        my $prevBuild = getPreviousBuild($build);
+        my $sameAsPrevious = defined $prevBuild && ($buildStatus == $prevBuild->buildstatus);
+
+        foreach my $ntfy_config (@config) {
+            next unless $jobName =~ /^$ntfy_config->{jobs}$/;
+
+            my $force = $ntfy_config->{force};
+
+            # If build is cancelled or aborted, do not send ntfy notification.
+            next if ! $force && $cancelledOrAborted;
+
+            # If there is a previous (that is not cancelled or aborted) build
+            # with same buildstatus, do not send ntfy notification.
+            next if ! $force && $sameAsPrevious;
+
+            my $server = $ntfy_config->{server} // "https://ntfy.sh";
+            my $topic;
+            if ($ntfy_config->{per_job}) {
+                $topic = $sanitize_topic->($ntfy_config->{topic} . "-" . $jobName);
+            } else {
+                $topic = $ntfy_config->{topic};
+            }
+
+            my $topic_key = $topic . ":" . $server;
+            $topics{$topic_key} //= { config => $ntfy_config, topic => $topic, builds => [] };
+            push @{$topics{$topic_key}->{builds}}, $build;
+        }
+    }
+
+    return if scalar keys %topics == 0;
+
+    my ($authors, $nrCommits) = getResponsibleAuthors($topbuild, $self->{plugins});
+
+    # Send a message to each topic.
+    foreach my $topic_key (keys %topics) {
+        my $topic_data = $topics{$topic_key};
+        my $ntfy_config = $topic_data->{config};
+        my @deps = grep { $_->id != $topbuild->id } @{$topic_data->{builds}};
+
+        my $server = $ntfy_config->{server} // "https://ntfy.sh";
+        my $topic = $topic_data->{topic};
+        my $url = "$server/$topic";
+
+        # Determine priority and tags based on build status
+        my $priority = $ntfy_config->{priority} // 3;
+        my @tags;
+        my $emoji;
+
+        if ($topbuild->buildstatus == 0) {
+            # Success
+            @tags = ("white_check_mark", "hydra");
+            $emoji = "âœ…";
+        } elsif ($topbuild->buildstatus == 2) {
+            # Dependency failed
+            @tags = ("warning", "hydra");
+            $emoji = "âš ï¸";
+            $priority = 4;
+        } elsif ($topbuild->buildstatus == 4) {
+            # Cancelled
+            @tags = ("no_entry", "hydra");
+            $emoji = "ðŸš«";
+        } else {
+            # Failed
+            @tags = ("x", "hydra");
+            $emoji = "âŒ";
+            $priority = 4;
+        }
+
+        my $title = "$emoji " . showStatus($topbuild) . ": " . showJobName($topbuild);
+        if (scalar @deps > 0) {
+            $title .= " (and " . scalar @deps . " others)";
+        }
+
+        my $message = "Build #" . $topbuild->id . " " . showStatus($topbuild) . " in " . renderDuration($topbuild) . "\n\n";
+        $message .= "$baseurl/build/" . $topbuild->id . "\n\n";
+
+        if (scalar keys %{$authors} > 0) {
+            my @author_names = sort keys %{$authors};
+            $message .= "Likely due to ";
+            $message .= "$nrCommits commits by " if $nrCommits > 1;
+            $message .= join(" or ", scalar @author_names > 1 ? join(", ", @author_names[0..scalar @author_names - 2]) : (), $author_names[-1]);
+            $message .= "\n";
+        }
+
+        if (scalar @deps > 0) {
+            $message .= "\nDependent builds that also failed:\n";
+            foreach my $dep (@deps) {
+                $message .= "â€¢ " . showJobName($dep) . " (#" . $dep->id . ")\n";
+            }
+        }
+
+        print STDERR "NtfyNotification: sending notification to topic '$topic' on server '$server'\n";
+
+        my $req = HTTP::Request->new('POST', $url);
+        $req->header('Content-Type' => 'text/plain; charset=utf-8');
+        $req->header('Title' => $title);
+        $req->header('Priority' => $priority);
+        $req->header('Tags' => join(",", @tags));
+        $req->header('Click' => "$baseurl/build/" . $topbuild->id);
+
+        if (defined $ntfy_config->{token}) {
+            $req->header('Authorization' => 'Bearer ' . $ntfy_config->{token});
+        }
+
+        $req->content($message);
+
+        my $ua = LWP::UserAgent->new();
+        my $response = $ua->request($req);
+
+        if (!$response->is_success) {
+            print STDERR "NtfyNotification: failed to send notification: " . $response->status_line . "\n";
+        }
+    }
+}
+
+1;
